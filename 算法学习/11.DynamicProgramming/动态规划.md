# 动态规划
## 常见的尝试模型
1. 从左到右尝试
2. 范围上的尝试模型
3. 多样本位置全对应的尝试模型
4. 寻找业务限制的尝试模型

## 暴力递归改动态规划
1. 暴力递归的base case ==> 对应dp表格的初始化
2. 暴力递归的分情况讨论 ==> 对应dp表的状态转移方程
3. 暴力递归的原始输入   ==> 对应dp表格的返回位置

### 可变参数的选择
1. 输入一个序列`X`的情况:
   - 第一次递归`reslut = process(const ValueType &X,int i, int others)`
   - 输入参数:
     1. 序列位置`i`
     2. 可选参数`other`。`other`参数含义从第一次递归中获取，`other`参数会影响当前`i`位置分情况讨论。
2. 输入两个序列`X`和`Y`的情况:
   - 第一次递归`process(const ValueType &X, const ValueType &Y, int index, int j)`
   - 可变参数:
      1. 序列的位置`i`
      2. 序列的位置`j`
3. 输入可能很多序列的情况，但是没有具体的序列的位置参数可用。
   - 第一次递归`process(const ValueType &XYZ，ValueType others)`
   - 输入参数:
      1. `others`唯一可变参数，`other`参数含义从第一次递归中获取，`other`参数会影响当前`i`位置分情况讨论。考虑使用`unordered_map<ValueType,result>`进行记忆化搜索。
   -  比如[leetcode 691.贴纸拼词](https://leetcode.cn/problems/stickers-to-spell-word/)

- 暴力递归有重复解，可以使用记忆化搜索优化
- 记忆化搜索能拆机成细粒度，可以优化
### 面试中暴力递归原则
1. 可变参数类型不要比`int`类型复杂
2. 可变参数类型比`int`复杂的情况，可变参数是唯一的，改进为到记忆化搜索即可。
3. 可变参数个数尽可能少
> 太难的之间放弃

## 记忆化搜索
可变参数重复的运算结果放入缓存`cache`中，下次计算直接获取。
由暴力递归该动态规划，不用在意原来的问题，关注其中的可变参数，使用 cache存储。
后效性，由于某些可变参数没有纳入考虑，只认为给定的参数作为可变参数。
- 无枚举行为时间复杂度与经典动态规划相当。
- 记忆化搜索有些时候比精细化动态规划好。因为精细动态规划会有一些情况的可能性为0的会遍历，但是记忆化搜索会跳过这些可能性为0的情况。

## 经典的动态规划
精细化结构，dp表，依次填充。
通过分析避免枚举方法。

## 后效性
取决于可变参数的选取，没有把所有的可变参数纳入考虑会导致后效性。


# 几种模型例子
## 1. 从左到右尝试
> 考虑`index`z之后的元素尝试的结果
### 背包问题 
1. 0、1 背包问题，
每个物品放与不放、不能超过背包容量
先遍历物品，再遍历从大到小背包容量(为了滚动更新时候不会冲突)
2. 完全背包问题

## 2. 范围上的尝试模型
> 考虑范围`[L,R]`之间的的元素尝试的结果，选个位置split分成`[L,split-1]`和`[split+1,R]`两个部分，`split`递归调用，加上记忆化搜索。
- [面试题 08.14. 布尔运算](https://leetcode.cn/problems/boolean-evaluation-lcci/)

## 3. 多样本位置全对应的尝试模型
通常以结尾位置划分情况
- [leetcode 72. 编辑距离](https://leetcode.cn/problems/edit-distance/)
- [leetcode 97.交错字符串](https://leetcode.cn/problems/interleaving-string/)

## 4. 寻找业务限制的尝试模型
洗咖啡杯


# 注意事项
`i,j`的含义是个数时，对应范围应该`[0, s.size()]`，对应下标应该是`i-1，j-1`
`i,j`的含义是下标时，对应范围应该`[0, s.size())`，对应下标应该是`i-1，j-1`

