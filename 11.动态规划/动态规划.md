## 图基础
顶点vertex
边edge
存储方式:邻接表、邻接矩阵等

建议方式
```c++
class graph
{
public:
    graph()
    {
    }
    unordered_map<int,*vertex> vertexs;
    unordered_set<*edge> edges;
};

template<class T>
class vertex
{
public:
    vertex( T value_):from(0),to(0);
    {
        value = value_;

    }
    T value;
    int to;//入度
    int from;//出度
    vector<edge*> edges;
    vector<vertex*> nexts;
};

class edge
{
public:
    edge(int distance_,vertex * from_,vertex * to_)
    {
        distance = distance_;
        from = from_;
        to = to_;
    }
    
    vertex *from;
    vertex *to;
    int distance;
};
```


### 遍历

#### 广度遍历优先

#### 深度优先算法

### 拓扑排序

### 最小生成树
K算法
P算法

### Dijkstra
计算两个节点之间的最大距离，edge不能有负数
广度优先更新当前最短距离节点到节连的所有节的最短距离，完成后固定当前节点



# 动态规划
## 常见的尝试模型
1. 从左到右尝试
2. 范围上的尝试模型
3. 多样本位置全对应的尝试模型
4. 寻找业务限制的尝试模型


## 记忆化搜索
可变参数重复的运算结果放入缓存`cache`中，下次计算直接获取。
由暴力递归该动态规划，不用在意原来的问题，关注其中的可变参数，使用 cache存储。
后效性，由于某些可变参数没有纳入考虑，只认为给定的参数作为可变参数。

## 经典的动态规划
精细化结构，dp表，依次填充。
通过分析避免枚举方法。

# 几种模型例子
## 1. 从左到右尝试
1. 背包问题

## 2. 范围上的尝试模型

## 3. 多样本位置全对应的尝试模型

## 4. 寻找业务限制的尝试模型
洗咖啡杯