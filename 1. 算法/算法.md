# 时间复杂度
## 时间复杂度排序
O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶
# 空间复杂度
空间复杂度是考虑程序**运行时占用内存的大小**，而不是可执行文件的大小。

## 递归算法
$T(n) = a*T(n/b) + O(n^d) $
满足以上递归公式的递归算法时间复杂度: O(nlogn)
1. $log_ba>d$ :时间复杂度$O(N^{log_ba})$
2. $log_ba<d$ :时间复杂度$O(N^d)$
3. $log_ba=d$ "时间复杂度$O(N^d*logn)$

## 常见排序算法
算法名称|时间复杂度|空间复杂度|大致描述
-|-|-|-
冒泡排序|O(N^2)|O(1)|每次遍历依次比较|
插入排序|O(N^2)|O(1)|每次对前面i个进行排序，当处理新的i+1个的时候，前只需要将第i+1个与前i个有效的进行比较排序
归并排序|O(nlogn)|额外空间复杂度O(N)|二分法，分块排序后，使用双指针的方式，申请一块新的空间存储合并排序后结果，完后在拷贝回来
快速排序算法|O(nlogn)|O(1)|随机选择一个基准，根据基准分块的排序。

### 冒泡排序
比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
- 时间复杂度 O(n²)
- 额外空间复杂度 不申请额外空间
1. 每次都需要比较操作
### 选择排序
step 1 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
step 2 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
step 3 重复第二步，直到所有元素均排序完毕。
- 时间复杂度 O(n²)
- 额外空间复杂度 
1. 每次都需要比较操作
### 插入排序
将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
从头到尾依次扫描未排序序列，将扫描到的每个元素插入到之前排序的**有序序列的适当位置**。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
### 归并排序
step 1 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
step 2 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
step 3 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
step 4 重复步骤 3 直到某一指针达到序列尾；
step 5 将另一序列剩下的所有元素直接复制到合并序列尾。
- 时间复杂度 O(nlogn)
- 额外空间复杂度 O(n)
1. 需要额外空间
2. 比较O(n²)算法节省了比较次数
### 快速排序
step 1 从数列中随机挑出一个元素，称为 "基准"（pivot）;
step 2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
step 3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
### 堆排序
step 1 创建一个堆 H[0……n-1]；
step 2 把堆首（最大值）和堆尾互换；
step 3 把堆的尺寸缩小 1，并调用 heapify(0)，目的是把新的数组顶端数据调整到相应位置；
step 4 重复步骤 2，直到堆的尺寸为 1。

H[0,...,i] 大跟堆为例子
heapinsert 往堆里插入新增数据
假设插入的为第i个位置数据
```c++
while(H[i]>H[(i-1)/2]||i>0)//比较i与父节点(第(i-1)/2向下取整的节点)
{
    swap(H[i],H[(i-1)/2]);//交换父节点与i节点
    i = (i-1/2);
}
```
heapify 梳理无序的一个节点的为根的节点
假设无序节点为第i个位置数据
```c++
while(i<heapsize)
{
    int maxH;//子节点中较大的一个
    if(H[2 * i + 1] > H[2 * i + 2])
    {
        maxH =  2 * i + 1;
    }
    else
    {
        maxH =  2 * i + 2;
    }

    if(H[i] >= H[maxH])
    {
        break;
    }    
    else
    {
        swap(H[i],H[maxH]);
        i = maxH;
    }
    
}
```
### 计数排序
step 1 找出待排序的数组中最大和最小的元素
step 2 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
step 3 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
step 4 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
### 桶排序
在额外空间充足的情况下，尽量增大桶的数量
使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中

cout[] 每个键值的计数
累加`for(i=0;i<coutsize-2;i++) {cout[i+1] += cout[i];} `统计小于某个键值的计数
从右到左取出`arr[]`元素放入 对应键值x的放入`arr[--cout[x]]`位置，就像从桶里面倒出来一样
因为放入位置为`arr[--cout[x]]`，是从右到左放的，所以是从右到左取出元素
### 基排序
基数排序：根据键值的每位数字来分配桶；
> 基数排序：根据键值的每位数字来分配桶；
  计数排序：每个桶只存储单一键值；
  桶排序：每个桶存储一定范围的数值；



# 内存
## 内存管理
区域名称|特点|作用
-|-|-
代码区|固定部分|存储二进制代码。
数据区|固定部分|全局变量、静态变量、常量等。
栈区(Stack) |可变部分|系统自动分配回收。
堆区(Heap)|可变部分|new出来的，需要手动delete。若程序员不释放，程序结束时可能由OS收回。


## 内存对齐
占用内存有所增加，可以加速提升计算效率。

# 数据性能对比

数据类型|插入/删除|查询|使用场景
-|-|-|-
数组|O(n)|O(1)|数据量固定，经常查询
链表|O(1)|O(n)|数据量不固定，频繁增删，较少查询