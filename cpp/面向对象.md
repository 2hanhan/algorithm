
# 面向对象的三大特性
## 封装
## 继承
### 构造与析构顺序
[可执行测试代码](code/test_const.cpp)
```c++
class A
{
public:
    A()
    {
        cout << "A()构造函数" << endl;
    }

    ~A()
    {
        cout << "~A()析构函数" << endl;
    }
};

class B
{
public:
    B()
    {
        cout << "B()构造函数" << endl;
    }

    ~B()
    {
        cout << "~B()析构函数" << endl;
    }
};

class C
{
public:
    C()
    {
        cout << "C()构造函数" << endl;
    }

    ~C()
    {
        cout << "~C()析构函数" << endl;
    }
};

class D
{
public:
    D()
    {
        cout << "D()构造函数" << endl;
    }

    ~D()
    {
        cout << "~D()析构函数" << endl;
    }
};

class E : public A, public B
{
public:
    E()
    {
        cout << "E()构造函数" << endl;
    }

    ~E()
    {
        cout << "~E()析构函数" << endl;
    }
    C c;
    D d;
};

// 测试构造和析构顺序
void test02()
{
    E e;
}

int main()
{
    test02();
}
```
输出结果
```bash
A()构造函数
B()构造函数
D()构造函数
C()构造函数
E()构造函数
~E()析构函数
~C()析构函数
~D()析构函数
~B()析构函数
~A()析构函数
```
#### 构造函数调用顺序
1. 基类，按照继承顺序
2. 成员类对象构造函数，按照成员定义
3. 派生类构造函数
#### 析构函数调用顺序
1. 派生类析构函数
2. 成员类对象析构函数，按照定义顺序的反序
3. 基类析构函数，按照继承顺序的反序

## 多态
### 静态多态 动态多态
- 静态多态：通过重载实现，在编译是确定函数调用
- 动态多态：通过继承和重写虚函数实现，在运行时候确定函数调用


# virtual关键字 和 虚函数
使用`virtual`关键字修饰的函数称为虚函数。
- 虚函数用于实现动态多态
- 构造函数、`static`修饰的静态函数、友元函数不能是虚函数。
- 析构函数一般定义为虚函数。因为当基类指针析构派生类时，如果基类的对象的析构函数不是虚函数，则只会调用派生类的虚函数，可能存在基类对象的内存泄漏问题。
## 虚函数
```c++
class A
{
    virtual void fun();
}
```
## 纯虚函数
```c++
class A
{
    virtual void fun();
}
```
- 包含纯虚函数的类，称为抽象类，抽象类无法实例化对象。
- 派生类如果不重写父类的纯虚函数也属于抽象类，无法实例化对象。
## 虚函数表
- 用来虚函数表记录虚函数的地址。
- 先生成基类的虚函数表，然后生成派生类的虚函数表。如果派生类中有重写基类的虚函数，则虚函数表使用派生类的虚函数地址替换基类中的虚函数地址。
- 每个类会有一个虚函数表。
- 类的对象的通过虚函数指针`vptr`（通过`this`指针访问虚函数指针`vptr`）访问虚函数表。
- 虚函数指针`vptr`在构造函数中生成。所以构造函数不能使虚函数。


# friend关键字 友元
- 友元可以访问类内的`protect`和`private`类型的数据
- 友元在类内声明，但是不属于该类的成员函数
- 友元函数访问类内的成员时候，需要传递需要对象做参数。因为友元没有`this`指针。



# 拷贝构造函数
- 使用引用传递。不能是值传递，因为值传递需要创建一个临时对象再次调用拷贝构造函数形成死循环。
- 调用：值传递对象，返回值是对象，一个对象通过另一个对象初始化